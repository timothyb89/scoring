package net.frcdb.scoring.schedule;

/**
 * An interface for constraining a schedule.  
 * @author gavin
 */
public abstract class AnnealingConstraint {
	
	private double temperature;
    private final double T_STEP;
    private final double ANNEAL_TIME;
    private final double T_MIN;
    private final double LOWEST_SCORE;

    /**
     * Creates a new annealing framework.
     * @param temperature The initial "temperature," a measure of how much hill climbing is allowed
     * @param tStep The amount to multiply the temperature by after each annealing.  It must be between zero
     * and 1, exclusively.
     * @param annealTime The number of moves computed at each temperature.
     * @param lowestScore The lowest score the evaluation function may take; the score for the optimal 
     * schedule.
     * @param lowestTemp The temperature at which the annealing will stop.  It must be greater than zero.
     */
    public AnnealingConstraint(double temperature, double tStep, double annealTime, double lowestScore,
            double lowestTemp) {
        if (tStep >= 1 || tStep <= 0) {
            throw new IllegalArgumentException("tStep must be between zero and one exclusive.");
        } else if (lowestTemp <= 0) {
            throw new IllegalArgumentException("lowestTemp must be greater than zero.");
        }
        this.temperature = temperature;
        T_STEP = tStep;
        ANNEAL_TIME = annealTime;
        LOWEST_SCORE = lowestScore;
        T_MIN = lowestTemp;
    }

    
    public abstract double eval(Schedule sched);

    public abstract Schedule move(Schedule sched);

    /**
     * Uses the Boltzmann probability function to determine if a schedule should be expected or not.  If the next 
     * schedule evaluates better than or equal to the current schedule, it is always accepted.  Otherwise, worse 
     * schedules are excepted with a probability dependent on how much worse they are than the current 
     * schedule and how high the temperature is.
     * @param cur The current schedule.
     * @param next The next schedule.
     * @return True, if the next schedule should be excepted; false otherwise.
     */
    private boolean boltzmannProb(Schedule cur, Schedule next) {
        double nextVal = eval(next);
        double curVal = eval(cur);
        if (nextVal <= curVal) {
            return true;
        } else {
            return Math.random() < Math.exp((curVal - nextVal) / temperature);
        }
    }

    /**
     * Uses annealing to generate schedules, while keeping track of the best one found.
     * @param initial The initial schedule, presumably the one generated by the default 
     * <code>Schedule</code> constructor, although any schedule separated into rounds is permissable.
     * @return The best schedule found.
     */
    public final Schedule anneal(Schedule initial) {
        Schedule best = initial;
        Schedule current = initial;
        Schedule next;
        for (; temperature > T_MIN; temperature *= T_STEP) {
            for (int i = 0; i < ANNEAL_TIME; i++) {
                next = move(current);
                if(boltzmannProb(current, next)) {
                    current = next;
                    if(eval(current) <= eval(best)) {
                        best = current;
                        if(eval(best) == LOWEST_SCORE) {
                            return best;
                        }
                    }
                }
            }
        }

        return best;
    }
	
}
